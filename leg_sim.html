<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2サーボ脚シミュレータ（定速サーボ＋通過点）</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121824; --fg:#e9eef7; --mut:#9fb0c6; --line:#2a3550; }
    body { margin:0; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif; background:var(--bg); color:var(--fg); }
    header { padding:12px 14px; border-bottom:1px solid var(--line); display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    header h1 { margin:0; font-size:16px; font-weight:700; }
    header .note { color:var(--mut); font-size:12px; }
    main { display:grid; grid-template-columns: 360px 1fr; gap:12px; padding:12px; }
    @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:12px; }
    .row { display:grid; grid-template-columns: 1fr 120px; gap:10px; align-items:center; margin:8px 0; }
    .row label { font-size:12px; color:var(--mut); }
    input[type="range"]{ width:100%; }
    input[type="number"], select { width:100%; background:#0d1320; color:var(--fg); border:1px solid var(--line); border-radius:8px; padding:6px 8px; }
    .btns { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    button { background:#0d1320; color:var(--fg); border:1px solid var(--line); border-radius:10px; padding:8px 10px; cursor:pointer; }
    button:hover{ border-color:#3a4b73; }
    .canvas-wrap { display:grid; grid-template-columns: 1fr; gap:12px; }
    canvas { width:100%; height:auto; background:#070a10; border:1px solid var(--line); border-radius:10px; }
    .small { font-size:12px; color:var(--mut); line-height:1.4; }
    .kpi { display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
    .kpi div { background:#0d1320; border:1px solid var(--line); border-radius:10px; padding:8px; }
    .kpi .v { font-weight:700; }
    .warn { color:#ffcc7a; }
  </style>
</head>
<body>
<header>
  <h1>2サーボ脚シミュレータ（定速サーボ＋通過点）</h1>
  <div class="note">モデルは「左右2基点からの2リンクIK（並列5節相当）」で、サーボは一定角速度で目標角へ移動（先に着いた側は待機）します。</div>
</header>

<main>
  <section class="panel">
    <div class="row">
      <label>形状（通過点配置）</label>
      <select id="shape">
        <option value="kamaboko">蒲鉾っぽい（水平線＋頂点）</option>
        <option value="triangle">二等辺三角形っぽい（底辺＋頂点）</option>
      </select>
    </div>

    <div class="row">
      <label>通過点数（4–6）</label>
      <input id="nPts" type="number" min="4" max="6" step="1" value="5">
    </div>

    <div class="row">
      <label>底辺の長さ（mm）</label>
      <input id="baseW" type="number" min="20" max="200" step="1" value="90">
    </div>

    <div class="row">
      <label>底辺の高さ（mm, y）</label>
      <input id="baseY" type="number" min="-120" max="120" step="1" value="0">
    </div>

    <div class="row">
      <label>頂点の高さ（mm, +）</label>
      <input id="apexH" type="number" min="5" max="140" step="1" value="45">
    </div>

    <hr style="border-color:var(--line); border-width:1px; border-style:solid; margin:12px 0;">

    <div class="row">
      <label>サーボ基点間距離 d（mm）</label>
      <input id="dBase" type="number" min="10" max="140" step="1" value="60">
    </div>

    <div class="row">
      <label>近位リンク長 L1（mm）</label>
      <input id="L1" type="number" min="10" max="160" step="1" value="55">
    </div>

    <div class="row">
      <label>遠位リンク長 L2（mm）</label>
      <input id="L2" type="number" min="10" max="180" step="1" value="55">
    </div>

    <div class="row">
      <label>サーボ角速度（deg/s）</label>
      <input id="omega" type="number" min="10" max="600" step="5" value="180">
    </div>

    <div class="row">
      <label>サーボ可動範囲（deg）</label>
      <select id="range">
        <option value="0-180">0–180</option>
        <option value="10-170">10–170（少し余裕）</option>
        <option value="20-160">20–160（さらに余裕）</option>
      </select>
    </div>

    <div class="row">
      <label>IKの肘の選び方</label>
      <select id="elbow">
        <option value="up">肘上（見た目安定しやすい）</option>
        <option value="down">肘下</option>
      </select>
    </div>

    <div class="btns">
      <button id="gen">Generate waypoints</button>
      <button id="reset">Reset</button>
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="step">Step</button>
      <button id="export">Export CSV</button>
    </div>

    <div class="kpi">
      <div><div class="small">状態</div><div class="v" id="status">停止</div></div>
      <div><div class="small">現在ターゲット</div><div class="v" id="tgt">—</div></div>
      <div><div class="small">θ1 / θ2（deg）</div><div class="v" id="angles">—</div></div>
      <div><div class="small">時刻（s）</div><div class="v" id="time">0.00</div></div>
    </div>

    <p class="small">
      ※「正確な蒲鉾／三角形を描く」ことより、<span class="warn">定速サーボ駆動で軌跡がどう歪むか</span>を見る想定です。<br>
      ※到達不能な通過点がある場合は、その点は自動でスキップ（ログに警告）します。
    </p>
  </section>

  <section class="canvas-wrap">
    <div class="panel">
      <div class="small">リンク姿勢・通過点・足先軌跡</div>
      <canvas id="view" width="980" height="520"></canvas>
    </div>
    <div class="panel">
      <div class="small">θ1/θ2 タイムライン（目標へ定速で移動、先着は待機）</div>
      <canvas id="plot" width="980" height="260"></canvas>
    </div>
  </section>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ---- UI elements
  const shapeEl = $("shape"), nPtsEl=$("nPts"), baseWEl=$("baseW"), baseYEl=$("baseY"), apexHEl=$("apexH");
  const dBaseEl=$("dBase"), L1El=$("L1"), L2El=$("L2"), omegaEl=$("omega"), rangeEl=$("range"), elbowEl=$("elbow");
  const genBtn=$("gen"), resetBtn=$("reset"), playBtn=$("play"), pauseBtn=$("pause"), stepBtn=$("step"), exportBtn=$("export");
  const statusEl=$("status"), tgtEl=$("tgt"), anglesEl=$("angles"), timeEl=$("time");

  const view = $("view"), vctx = view.getContext("2d");
  const plot = $("plot"), pctx = plot.getContext("2d");

  // ---- Simulation state
  let waypoints = [];         // {x,y,label}
  let targets = [];           // {theta1,theta2, ok, wpIndex}
  let segs = [];              // segments built from targets with durations and holds
  let running = false;
  let t = 0;                  // current time [s]
  let dt = 1/60;              // simulation timestep
  let theta1 = 90, theta2 = 90; // current angles [deg]
  let segIndex = 0;           // current segment index
  let trail = [];             // foot positions for drawing
  let samples = [];           // time series for plot: {t,th1,th2}

  // ---- Helpers
  function deg2rad(d){ return d*Math.PI/180; }
  function rad2deg(r){ return r*180/Math.PI; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function parseRange(){
    const s = rangeEl.value;
    if (s==="0-180") return [0,180];
    if (s==="10-170") return [10,170];
    return [20,160];
  }

  function getParams(){
    return {
      shape: shapeEl.value,
      nPts: clamp(parseInt(nPtsEl.value||5,10),4,6),
      baseW: parseFloat(baseWEl.value||90),
      baseY: parseFloat(baseYEl.value||0),
      apexH: parseFloat(apexHEl.value||45),
      dBase: parseFloat(dBaseEl.value||60),
      L1: parseFloat(L1El.value||55),
      L2: parseFloat(L2El.value||55),
      omega: parseFloat(omegaEl.value||180), // deg/s
      elbow: elbowEl.value, // up/down
      range: parseRange()
    };
  }

  // World <-> Screen transform (mm to px)
  function makeTransform(){
    // Fit a reasonable world box in the view
    const P = getParams();
    const margin = 30;
    const w = view.width, h = view.height;

    // World extents (rough)
    const xmin = -P.dBase/2 - (P.L1+P.L2) - 20;
    const xmax =  P.dBase/2 + (P.L1+P.L2) + 20;
    const ymin = - (P.L1+P.L2) - 60;
    const ymax =   (P.L1+P.L2) + 80;

    const sx = (w-2*margin)/(xmax-xmin);
    const sy = (h-2*margin)/(ymax-ymin);
    const s = Math.min(sx, sy);

    const ox = margin - xmin*s;
    const oy = h - margin + ymin*s; // y up -> screen down
    return {s, ox, oy};
  }
  function W2S(x,y,tr){
    return { x: tr.ox + x*tr.s, y: tr.oy - y*tr.s };
  }

  // ---- Kinematics (parallel 2-link IK for each base pivot)
  // Two servos at base points B1(-d/2,0) and B2(+d/2,0)
  // Each side: base -> elbow (L1) -> foot (L2)
  // Solve theta at base for each side.
  function ik2link(base, foot, L1, L2, elbow){
    const dx = foot.x - base.x;
    const dy = foot.y - base.y;
    const r2 = dx*dx + dy*dy;
    const r = Math.sqrt(r2);

    // reachability
    if (r > L1+L2 || r < Math.abs(L1-L2)) return {ok:false};

    const a = Math.atan2(dy, dx);
    // law of cosines for angle at base
    const c = (L1*L1 + r2 - L2*L2)/(2*L1*r);
    const alpha = Math.acos(clamp(c,-1,1));
    // elbow selection: "up" means smaller or larger? We'll map:
    const th = (elbow==="up") ? (a + alpha) : (a - alpha);
    return {ok:true, theta: rad2deg(th)};
  }

  function fkElbow(base, thetaDeg, L1){
    const th = deg2rad(thetaDeg);
    return { x: base.x + L1*Math.cos(th), y: base.y + L1*Math.sin(th) };
  }

  function fkFootFromElbow(elbowPt, footPt){
    // we already know foot target point in IK planning
    return footPt;
  }

  function normalizeAngleToRange(theta, minDeg, maxDeg){
    // theta can be any degree; bring it into [min,max] if possible by adding/subtracting 360
    let best = theta;
    // Try shifts
    const candidates = [theta, theta+360, theta-360, theta+720, theta-720];
    let ok = null;
    for (const c of candidates){
      if (c>=minDeg && c<=maxDeg){
        ok = c;
        break;
      }
    }
    if (ok===null){
      // clamp to range as fallback
      best = clamp(theta, minDeg, maxDeg);
      return {ok:false, theta: best};
    }
    return {ok:true, theta: ok};
  }

  // ---- Waypoints generation
  function generateWaypoints(){
    const P = getParams();
    const n = P.nPts;

    const left = -P.baseW/2;
    const right = P.baseW/2;
    const y0 = P.baseY;

    const pts = [];
    // bottom points evenly spaced (n-1 points on line), and one apex
    const bottomCount = Math.max(3, n-1); // ensure at least 3 on bottom line
    // If n=4 => bottom 3 + apex 1; n=6 => bottom 5 + apex 1
    for (let i=0;i<bottomCount;i++){
      const u = (bottomCount===1)?0.5:i/(bottomCount-1);
      const x = left + (right-left)*u;
      pts.push({x, y:y0, label:`B${i+1}`});
    }
    // apex at midpoint above
    const apex = {x:(left+right)/2, y:y0 + P.apexH, label:"A"};
    // Order (loop): for kamaboko: go along bottom left->right, then apex, then back to left
    if (P.shape==="kamaboko"){
      const ordered = [...pts, apex];
      // make it cyclic by returning to first point (implicit in segments)
      return ordered;
    } else {
      // triangle-ish: left bottom -> apex -> right bottom -> (and intermediate bottom points by bouncing)
      // We’ll build a simple order that still visits all bottoms: left->apex->right->(walk back on bottom points)
      const ordered = [];
      ordered.push(pts[0]);
      ordered.push(apex);
      ordered.push(pts[pts.length-1]);
      // fill remaining bottom points (excluding ends) from right to left
      for (let i=pts.length-2;i>=1;i--){
        ordered.push(pts[i]);
      }
      return ordered;
    }
  }

  function buildTargetsFromWaypoints(){
    const P = getParams();
    const d = P.dBase;
    const B1 = {x:-d/2, y:0};
    const B2 = {x:+d/2, y:0};

    const [minDeg,maxDeg] = P.range;

    const tgs = [];
    for (let i=0;i<waypoints.length;i++){
      const wp = waypoints[i];
      const ik1 = ik2link(B1, wp, P.L1, P.L2, P.elbow);
      const ik2 = ik2link(B2, wp, P.L1, P.L2, P.elbow);
      if (!ik1.ok || !ik2.ok){
        console.warn("Unreachable waypoint:", wp);
        tgs.push({ok:false, wpIndex:i});
        continue;
      }
      const n1 = normalizeAngleToRange(ik1.theta, minDeg, maxDeg);
      const n2 = normalizeAngleToRange(ik2.theta, minDeg, maxDeg);
      const ok = n1.ok && n2.ok;
      if (!ok) console.warn("Angle out of range, clamped:", wp, n1, n2);

      tgs.push({ok:true, theta1:n1.theta, theta2:n2.theta, wpIndex:i});
    }
    return tgs;
  }

  // Segment planning: move to each target at constant omega, both start together, duration = max(dθ)/ω.
  function buildSegments(){
    const P = getParams();
    const omega = Math.max(1e-6, P.omega);

    const valid = targets.map((tg,idx)=>({tg,idx})).filter(x=>x.tg && x.tg.ok);

    if (valid.length < 2){
      console.warn("Not enough valid targets.");
      return [];
    }

    const s = [];
    // start from current theta1/theta2, snap to first valid target
    const first = valid[0].tg;
    theta1 = first.theta1; theta2 = first.theta2;

    for (let k=1;k<valid.length;k++){
      const a = valid[k-1].tg;
      const b = valid[k].tg;
      const d1 = b.theta1 - a.theta1;
      const d2 = b.theta2 - a.theta2;
      const dur = Math.max(Math.abs(d1), Math.abs(d2)) / omega; // seconds
      s.push({
        from:{t1:a.theta1, t2:a.theta2},
        to:{t1:b.theta1, t2:b.theta2},
        dur: Math.max(dur, 1e-3),
        wpFrom: a.wpIndex,
        wpTo: b.wpIndex
      });
    }
    // close the loop back to first valid (cyclic)
    const last = valid[valid.length-1].tg;
    const back = valid[0].tg;
    const dd1 = back.theta1 - last.theta1;
    const dd2 = back.theta2 - last.theta2;
    const dback = Math.max(Math.abs(dd1), Math.abs(dd2)) / omega;
    s.push({
      from:{t1:last.theta1, t2:last.theta2},
      to:{t1:back.theta1, t2:back.theta2},
      dur: Math.max(dback, 1e-3),
      wpFrom: last.wpIndex,
      wpTo: back.wpIndex
    });
    return s;
  }

  // Given theta1/theta2, compute elbow points and estimate foot point by intersecting circles (each elbow->foot radius L2).
  // But for plotting, we want a single foot point: we choose the point that is closest to current waypoint linearly blended,
  // or pick consistent intersection ("above" vs "below") using elbow mode.
  function solveFootFromAngles(){
    const P = getParams();
    const d = P.dBase;
    const B1 = {x:-d/2, y:0};
    const B2 = {x:+d/2, y:0};

    const E1 = fkElbow(B1, theta1, P.L1);
    const E2 = fkElbow(B2, theta2, P.L1);

    // foot is intersection of circles centered at E1 and E2 with radius L2.
    const r = P.L2;
    const dx = E2.x - E1.x;
    const dy = E2.y - E1.y;
    const D = Math.sqrt(dx*dx + dy*dy);

    if (D < 1e-6 || D > 2*r){
      // no intersection; return midpoint as fallback
      return {B1,B2,E1,E2, F:{x:(E1.x+E2.x)/2, y:(E1.y+E2.y)/2}, ok:false};
    }

    const a = D/2; // since radii equal
    const h = Math.sqrt(Math.max(0, r*r - a*a));
    const xm = E1.x + a*dx/D;
    const ym = E1.y + a*dy/D;

    // two intersections
    const rx = -dy*(h/D);
    const ry =  dx*(h/D);
    const F1 = {x: xm + rx, y: ym + ry};
    const F2 = {x: xm - rx, y: ym - ry};

    // choose based on elbow preference: "up" -> larger y
    const F = (P.elbow==="up") ? (F1.y>=F2.y?F1:F2) : (F1.y<=F2.y?F1:F2);

    return {B1,B2,E1,E2, F, ok:true};
  }

  // ---- Drawing
  function clear(ctx, w, h){
    ctx.clearRect(0,0,w,h);
  }

  function drawView(){
    const tr = makeTransform();
    clear(vctx, view.width, view.height);

    // Grid
    vctx.save();
    vctx.globalAlpha = 0.25;
    vctx.strokeStyle = "#24304a";
    vctx.lineWidth = 1;
    const step = 10; // mm
    const P = getParams();
    const xmin = -P.dBase/2 - (P.L1+P.L2) - 20;
    const xmax =  P.dBase/2 + (P.L1+P.L2) + 20;
    const ymin = - (P.L1+P.L2) - 60;
    const ymax =   (P.L1+P.L2) + 80;
    for (let x = Math.floor(xmin/step)*step; x<=xmax; x+=step){
      const a = W2S(x,ymin,tr), b=W2S(x,ymax,tr);
      vctx.beginPath(); vctx.moveTo(a.x,a.y); vctx.lineTo(b.x,b.y); vctx.stroke();
    }
    for (let y = Math.floor(ymin/step)*step; y<=ymax; y+=step){
      const a = W2S(xmin,y,tr), b=W2S(xmax,y,tr);
      vctx.beginPath(); vctx.moveTo(a.x,a.y); vctx.lineTo(b.x,b.y); vctx.stroke();
    }
    vctx.restore();

    const st = solveFootFromAngles();
    const {B1,B2,E1,E2,F} = st;

    // Trail
    vctx.save();
    vctx.strokeStyle = "#58c7ff";
    vctx.lineWidth = 2;
    vctx.globalAlpha = 0.9;
    vctx.beginPath();
    for (let i=0;i<trail.length;i++){
      const p = W2S(trail[i].x, trail[i].y, tr);
      if (i===0) vctx.moveTo(p.x,p.y); else vctx.lineTo(p.x,p.y);
    }
    vctx.stroke();
    vctx.restore();

    // Waypoints
    vctx.save();
    for (let i=0;i<waypoints.length;i++){
      const wp = waypoints[i];
      const p = W2S(wp.x, wp.y, tr);
      vctx.fillStyle = "#ffd36a";
      vctx.globalAlpha = 0.95;
      vctx.beginPath(); vctx.arc(p.x,p.y,5,0,Math.PI*2); vctx.fill();
      vctx.fillStyle = "#9fb0c6";
      vctx.font = "12px system-ui";
      vctx.fillText(wp.label, p.x+7, p.y-7);
    }
    vctx.restore();

    // Links
    function drawSeg(A,B, color, w=3, alpha=1){
      const a = W2S(A.x,A.y,tr), b=W2S(B.x,B.y,tr);
      vctx.save();
      vctx.strokeStyle = color;
      vctx.lineWidth = w;
      vctx.globalAlpha = alpha;
      vctx.beginPath(); vctx.moveTo(a.x,a.y); vctx.lineTo(b.x,b.y); vctx.stroke();
      vctx.restore();
    }

    drawSeg(B1,E1,"#9ad7ff",4,1);
    drawSeg(B2,E2,"#9ad7ff",4,1);
    drawSeg(E1,F,"#d7ff9a",4,1);
    drawSeg(E2,F,"#d7ff9a",4,1);

    // Base points & joints
    function dot(Pt, r, color){
      const p = W2S(Pt.x,Pt.y,tr);
      vctx.save();
      vctx.fillStyle = color;
      vctx.beginPath(); vctx.arc(p.x,p.y,r,0,Math.PI*2); vctx.fill();
      vctx.restore();
    }
    dot(B1,7,"#ffffff");
    dot(B2,7,"#ffffff");
    dot(E1,6,"#b3c9ff");
    dot(E2,6,"#b3c9ff");
    dot(F,7,"#58c7ff");

    // Axes label
    vctx.save();
    vctx.fillStyle = "#9fb0c6";
    vctx.font = "12px system-ui";
    vctx.fillText("x (mm)", 14, 18);
    vctx.fillText("y (mm)", 14, 34);
    vctx.restore();
  }

  function drawPlot(){
    clear(pctx, plot.width, plot.height);
    const w = plot.width, h = plot.height;

    // background grid
    pctx.save();
    pctx.globalAlpha = 0.25;
    pctx.strokeStyle = "#24304a";
    pctx.lineWidth = 1;
    const gx = 10, gy = 8;
    for (let i=0;i<=gx;i++){
      const x = i*w/gx;
      pctx.beginPath(); pctx.moveTo(x,0); pctx.lineTo(x,h); pctx.stroke();
    }
    for (let j=0;j<=gy;j++){
      const y = j*h/gy;
      pctx.beginPath(); pctx.moveTo(0,y); pctx.lineTo(w,y); pctx.stroke();
    }
    pctx.restore();

    if (samples.length < 2) return;

    // plot over last window
    const windowSec = 6.0;
    const tmax = samples[samples.length-1].t;
    const tmin = Math.max(0, tmax - windowSec);

    const [minDeg,maxDeg] = parseRange();
    const pad = 18;

    function X(tt){ return pad + (tt - tmin)/(tmax - tmin + 1e-6) * (w - 2*pad); }
    function Y(th){ return h - pad - (th - minDeg)/(maxDeg - minDeg) * (h - 2*pad); }

    // θ1
    pctx.save();
    pctx.strokeStyle = "#9ad7ff";
    pctx.lineWidth = 2;
    pctx.beginPath();
    let started=false;
    for (const s of samples){
      if (s.t < tmin) continue;
      const x = X(s.t), y = Y(s.th1);
      if (!started){ pctx.moveTo(x,y); started=true; } else pctx.lineTo(x,y);
    }
    pctx.stroke();
    pctx.restore();

    // θ2
    pctx.save();
    pctx.strokeStyle = "#d7ff9a";
    pctx.lineWidth = 2;
    pctx.beginPath();
    started=false;
    for (const s of samples){
      if (s.t < tmin) continue;
      const x = X(s.t), y = Y(s.th2);
      if (!started){ pctx.moveTo(x,y); started=true; } else pctx.lineTo(x,y);
    }
    pctx.stroke();
    pctx.restore();

    // legend
    pctx.save();
    pctx.fillStyle = "#9fb0c6";
    pctx.font = "12px system-ui";
    pctx.fillText("θ1", 12, 14);
    pctx.fillStyle = "#9ad7ff";
    pctx.fillRect(36,6,14,8);
    pctx.fillStyle = "#9fb0c6";
    pctx.fillText("θ2", 60, 14);
    pctx.fillStyle = "#d7ff9a";
    pctx.fillRect(84,6,14,8);
    pctx.restore();
  }

  // ---- Simulation update
  function setStatus(txt){ statusEl.textContent = txt; }
  function updateHUD(){
    timeEl.textContent = t.toFixed(2);
    anglesEl.textContent = `${theta1.toFixed(1)} / ${theta2.toFixed(1)}`;
    if (segs.length){
      const s = segs[segIndex % segs.length];
      const a = waypoints[s.wpTo] ? waypoints[s.wpTo].label : "?";
      tgtEl.textContent = `${a}（seg ${segIndex+1}/${segs.length}）`;
    } else {
      tgtEl.textContent = "—";
    }
  }

  function resetAll(){
    running = false;
    t = 0;
    segIndex = 0;
    trail = [];
    samples = [];
    // default pose
    theta1 = 90; theta2 = 90;
    setStatus("停止");
    updateHUD();
    drawView();
    drawPlot();
  }

  function rebuild(){
    waypoints = generateWaypoints();
    targets = buildTargetsFromWaypoints().filter(x=>x.ok);
    if (targets.length < 2){
      console.warn("Too few valid targets. Adjust geometry/waypoints.");
    }
    segs = buildSegments();
    trail = [];
    samples = [];
    t = 0;
    segIndex = 0;
    setStatus("準備完了");
    updateHUD();
    drawView();
    drawPlot();
  }

  let segT = 0; // time inside current segment
  function stepSim(){
    if (!segs.length) return;

    const P = getParams();
    const omega = P.omega; // deg/s

    let seg = segs[segIndex % segs.length];

    // segment local time
    segT += dt;
    const u = clamp(segT / seg.dur, 0, 1);

    // Both servos try to move at omega toward target; if one finishes early, it holds.
    // Equivalent to: compute desired linear interpolation, then clamp by max speed.
    const target1 = seg.to.t1;
    const target2 = seg.to.t2;

    function moveConstSpeed(cur, tgt){
      const diff = tgt - cur;
      const step = omega * dt;
      if (Math.abs(diff) <= step) return tgt;
      return cur + Math.sign(diff)*step;
    }

    const prev1 = theta1, prev2 = theta2;
    theta1 = moveConstSpeed(theta1, target1);
    theta2 = moveConstSpeed(theta2, target2);

    // If both reached, advance to next segment
    const done1 = Math.abs(theta1 - target1) < 1e-6;
    const done2 = Math.abs(theta2 - target2) < 1e-6;
    if (done1 && done2){
      segIndex = (segIndex + 1) % segs.length;
      segT = 0;
    }

    // record
    const st = solveFootFromAngles();
    trail.push({x: st.F.x, y: st.F.y});
    if (trail.length > 2000) trail.shift();

    samples.push({t, th1:theta1, th2:theta2});
    if (samples.length > 5000) samples.shift();

    t += dt;
    updateHUD();
    drawView();
    drawPlot();
  }

  function loop(){
    if (running) stepSim();
    requestAnimationFrame(loop);
  }

  // ---- CSV export
  function exportCSV(){
    if (!samples.length){
      alert("データがありません（Generate→Play してから）");
      return;
    }
    let csv = "t,theta1_deg,theta2_deg\n";
    for (const s of samples){
      csv += `${s.t.toFixed(4)},${s.th1.toFixed(3)},${s.th2.toFixed(3)}\n`;
    }
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "leg_angles.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ---- Wire UI
  genBtn.addEventListener("click", rebuild);
  resetBtn.addEventListener("click", resetAll);
  playBtn.addEventListener("click", ()=>{ running=true; setStatus("再生中"); });
  pauseBtn.addEventListener("click", ()=>{ running=false; setStatus("停止"); });
  stepBtn.addEventListener("click", ()=>{ running=false; setStatus("停止（ステップ）"); stepSim(); });
  exportBtn.addEventListener("click", exportCSV);

  // Auto init
  rebuild();
  loop();
})();
</script>
</body>
</html>